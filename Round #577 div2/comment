Problem A和Problem B都很简单

Problem C
这个题给出一个数组a[n]以及一个允许的操作总数k，每次操作为选择数组中任意一个元素增加1，问最终可能的最大的中位数。

第一步对数组进行排序，然后有两种办法。
在virtual contest中我自己写的答案是一个模拟算法，时间复杂度为O(n)：从数组的正中间向右逐个进行扫描，在扫描过程中，
维护一个变量weight，代表对于当前扫描过的数组来说，使得数组的中位数增加1需要消耗的操作的数量；
例如当1 2 3| 4 5时，weight=1；当1 2 4 4|5时，weight=2；当1 2 3 3 3|时，weight=3；除此之外，
还需维护一个变量space，代表在当前weight不变的情况下，中位数至多能增加的值。
而在Editorial里给出的方法是一个利用二分的O(log(INT_MAX))的算法：二分的下界设置为数组的原本的中位数，
上界设置为INT_MAX；每次判断如果需要将数组的中位数的值增加为mid，允许的操作的数量是否充足；
若不充足，则rb=mid-1；若充足，再判断mid是否为最大的可能值（即判断对于mid+1来说操作的数量是否充足）。
