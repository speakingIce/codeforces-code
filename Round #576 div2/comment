Problem A City Day
输入n，x，y，然后输入数组a[n]；
找出其中的一个元素，该元素的前面x个元素（如果存在）和后面y个元素（如果存在）都比它大。
根据问题的规模可知，使用暴力的做法即可：对数组中的每一个元素，比较它和之前x个元素以及之后y个元素的大小关系。

Problem B Water Lily
设要求的长度为x，根据勾股定理即可解出x。
注意到两个1e6的整数相乘会突破int型的限制，并且注意到输出的精度问题（使用printf("%.6f")输出即可）。

Problem C MP3
输入n和I，然后输入数组a[n]；
可以选取一个范围[l, r]对数组a[n]进行压缩，大于r的元素变为r，小于l的元素变为l；
设最终得到的数组中不同的元素的个数为K，必须满足ceil(log2(K))*n<I*8；
需要输出最小的更改的数组元素的个数。
可以使用滑动窗口的思想。先将从小到大a[n]排序，设lb和rb是窗口的边界；
不断地增加rb，并随时统计窗口中不同元素的个数K；
当K过大时，不断增加lb，直到K减小1为止；
持续这个过程，并在该过程中不断地统计窗口中包含元素的最大值。

Problem D Welfare State
给出n个初始的balance值，以及q个操作；
每次操作的格式可能是：
1 p x，即将第p个balance更改为x
2 x，即对每一个balance值，如果它小于x则将它设置为x
输出q次操作后的n个balance值。
可以使用线段树来解题。需要在每一个节点中维护相应区间的最小值；并且需要维护一个payout标签（相当于lazy标签），该payout标签代表了一次在该区间上的2 x操作；
在进行单点修改和查询的时候，需要将经过的节点的payout标签下传；
在进行2 x操作的时候，仅需更新根节点的payout标签即可。、

Problem E Matching vs Independent Set
给出一个有3n个结点和m条边的无向图（无自环，无重边），需要找出一个包含n条边的Matching或者包含n个结点的Independent Set；
当上述的Matching和Independent Set都不存在的时候输出Impossible。
事实上，不可能既不存在Matching也不存在Independent Set。
如果一张图中不存在Matching，则不可能找到n条互相没有公共结点的边（简称为“独立边”）。我们至多能找到(n-1)条独立边。
我们按照贪心的方法找到n0条独立边（n0<=(n-1)），则剩下的边的两个端点都必然属于这些独立边。
那么我们对这n0条独立边的端点进行记（一共有2n0个端点），则剩下的未记录的结点即一共有3n-2n0>=3n-2(n-1)=(n+2)个；
所以此时一定存在Independent Set。

Problem F Rectangle Painting 1
给出一张nxn的图，其中每一个单元格被染色为黑色或者白色；
将axb的矩形染为白色的代价为max(a, b)；
求将所有的单元格都染为白色的最小代价。
该题目可以使用搜索的方法进行求解。
设dfs(lx, ly, rx, ry)返回将左下角(lx, ly)和右上角(rx, ry)包围起来的矩形染为白色的最小代价。
则答案应该为dfs(0, 0, n - 1. n - 1)。
递归地对dfs进行求解：
  1. 如果(lx, ly)(rx, ry)已经是单元格，则问题的解平凡
  2. 将(lx, ly)(rx, ry)当做一个整体进行染色res = max(rx - lx + 1, ry - ly + 1)
  3. 将(lx, ly)(rx, ry)进行划分
    3.1 利用水平线进行划分
    3.2 利用垂直线进行划分
  4. combine
